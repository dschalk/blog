{
  "version": 3,
  "file": "bundle.css",
  "sources": [
    "../src/Blog.svelte",
    "../src/Monad.svelte",
    "../src/Haskell.svelte"
  ],
  "sourcesContent": [
    "\n<script>\n\n   import {fade} from \"svelte/transition\"\n   let visible = true;\n\n    import Monad from './Monad.svelte'\n    import Monad2 from './Monad2.svelte'\n    import Monad3 from './Monad3.svelte'\n    import Haskell from './Haskell.svelte'\n    import Bugs from './Bugs.svelte'\n    import Matrix from './Matrix.svelte'\n    import Transducer from './Transducer.svelte'\n    import Asynchronous_Monad from './Asynchronous_Monad.svelte'\n    import ToggleTheme from './ToggleTheme.svelte'\n    import Home from './Home.svelte'\n\n    var j = 0\n\n    function monad () {j = 1; console.log(j)};\n    function monad2 () {j = 2; console.log(j)};\n    function monad3 () {j = 9; console.log(j)};\n    function haskell () {j = 3; console.log(j)};\n    function bugs () {j = 4; console.log(j)};\n    function matrix () {j = 5; console.log(j)};\n    function transduce () {j = 6}; console.log(j);\n    function async () {j = 7; console.log(j)};\n    function tog () {j = 8; console.log(j)};\n    function home () {j = 0; console.log(j)};\n\n    $: j\n\n    console.log(\"j is\", j)\n\n\n</script>\n\n<style>\n\nbutton {\n   font-size: 18px;\n   color: #bccbaa;\n\n}\n\n.gamma {\n  display: block;\n  margin-left: auto;\n  margin-right: auto;\n  width: 50%;\n}\n\n  ul {  display: block;\n  margin-left: auto;\n  margin-right: auto;\n  width: 50%;\n     list-style: none;\n  }\n\n  tao {\n    margin-left: 3%;\n  }\n\n  .narrow {\n    font-family: monospace;\n    font-size: 22px;\n    margin-left: auto;  display: block;\n  margin-left: auto;\n  margin-right: auto;\n  width: 50%;\n    margin-right: auto;\n    display: block;\n    text-indent: 1.6%;\n  }\n</style>\n<div class=\"content\">\n<br><br>\n\n                        <div style = \"display: flex\">\n\n                        <div style = \"margin-Right: 2%; width: 20%\" >\n                        <br><br><br><br><br><br><br>\n                        <ul style = \"list-style: none;\">\n                        <li><div class='button'  on:click={matrix}>Why Svelte</div></li>\n                        <br>\n                        <li><div>MONAD SERIES</div></li>\n                        <br>\n                        <li><div class='button'  on:click={monad}>A Simple Monad</div></li>\n                        <br>\n                        <li><div class='button'  on:click={monad2}>Asynchronous Monads</div></li>\n                        <br>\n                        <li><div class='button'  on:click={monad3}>Promises Monad</div></li>\n                        <br>\n                        <li><div class='button'  on:click={transduce}>Transducer Simulator</div></li>\n                        <br>\n                        <li><div>MISCELANEOUS TOPICS</div></li>\n                        <br>\n                        <li><div class='button' on:click={haskell}>Hidden Haskell Information</div></li>\n                        <br>\n                        <li><div class='button'  on:click={bugs}>Bed Bug Eradication</div></li>\n                        <br>\n                        <li><div class='button'  on:click={tog}>Toggle Theme</div></li>\n                        <br>\n                        <li><div class='button'  on:click={home}>Home</div></li>\n                        <br>\n                        </ul>\n                        </div>\n                        <div style = \"margin-Right: 2%; width: 80%\" >\n                        <div style=\" font-weight: 900; font-size: 45px; color: #bbbb00; text-align: center; \">DAVID SCHALK'S BLOG</div>\n\n\n{#if j === 0}\n\t\t<Home />\n{/if}\n{#if j === 1}\n<Monad />\n{/if}\n{#if j === 2}\n<Monad2 />\n{/if}\n{#if j === 9}\n<Monad3 />\n{/if}\n{#if j === 3}\n<Haskell />\n{/if}\n{#if j === 4}\n<Bugs />\n{/if}\n{#if j === 5}\n<Matrix />\n{/if}\n{#if j === 6}\n<Asynchronous_Monad />\n{/if}\n{#if j === 7}\n<Transducer />\n{/if}\n{#if j === 8}\n<ToggleTheme />\n{/if}\n\n\n<br><br><br>\n</div>\n</div>\n</div>\n<br><br>\n",
    "\n<script>\nimport {fade} from \"svelte/transition\"\nlet visible = true;\n\nlet monadDisplay = `function Monad (z) {\n    var x = z;\n    var foo = function foo (func) {\n        var stop = 'stop';\n        if (func.name === 'stop') return x\n        else {\n            x = func(x);\n            return foo;\n        }\n    };\n    return foo;\n}\n\nconst prod = a => b => a*b;\nconst sum = a => b => a+b;`\n\nlet bonadsD = `function bonads(num) {\nreturn [Monad(num)(sum(7))(prod(4))(v=>v-10)(stop),\nMonad(num-1)(sum(7))(prod(4))(v=>v-10)(stop),\nMonad(num-2)(sum(7))(prod(4))(v=>v-10)(stop),\nMonad(num-3)(sum(7))(prod(4))(v=>v-10)(stop),\nMonad(num-2)(sum(7))(prod(4))(v=>v-10)(stop),\nMonad(num-1)(sum(7))(prod(4))(v=>v-10)(stop),\nMonad(num-0)(sum(7))(prod(4))(v=>v-10)(stop)]}`\n\nlet axe = `\nlet mon = Monad(3);\nlet a = mon(x=>x**3)(x=>x+3)(x=>x**2)(stop);\nconsole.log(\"a is\", a)  // a is 900`\n\nlet tree = `\nmon(x => x/100)\nconsole.log(\"mon(stop) now is\",mon(stop))  // mon(stop) now is 9 `\n\nlet fred = `\nlet ar = [];\nlet mon = Monad(3);\nlet mon2 = Monad();\nar.push(mon(stop));\nvar a = mon(x=>x**3)(x=>x+3)(x=>x**2)\nar.push(a);\nar.push(mon(x => x/100);\nar.push(mon2(mon(stop)(x=>x*100)))\nconsole.log(\"ar.map(v=>v('stop')) is\", ar.map(v=>v('stop')))  // [3, 900, 9] `\n\nfunction Monad (z) {\n  var x = z;\n  var stop = \"stop\";\n  var foo = function foo (func) {\n    if (func.name === \"stop\") return x\n    else {\n      x = func(x);\n      return foo;\n    }\n  };\n  return foo;\n}\n\nconst prod = a => b => a*b;\nconst sum = a => b => a+b;\n\nlet num = 6;\n\nlet bonads = function bonads(num) {\nreturn [Monad(num)(sum(7))(prod(4))(v=>v-10)(stop),\nMonad(num-1)(sum(7))(prod(4))(v=>v-10)(stop),\nMonad(num-2)(sum(7))(prod(4))(v=>v-10)(stop),\nMonad(num-3)(sum(7))(prod(4))(v=>v-10)(stop),\nMonad(num-2)(sum(7))(prod(4))(v=>v-10)(stop),\nMonad(num-1)(sum(7))(prod(4))(v=>v-10)(stop),\nMonad(num-0)(sum(7))(prod(4))(v=>v-10)(stop)]}\n\n\nlet mona = bonads(num);\n$: mona\nconsole.log(mona)\n\nfunction numF (e) {num = e.target.value; console.log(\"e.target.value is\", e.target.value); return e.target.value}\n$: num\n\nconsole.log(\"num is\", num);\n</script>\n\n<style>\n.tao {\n  margin-left: 3%;\n}\n\nh3 {\n   font-size: 27px;\n}\n\n#aside {\n    font-size: 18px;\n    color: #eeaaff;\n    font-style: italic;\n}\n</style>\n<br><br><br>\n {#if visible}\n \t<div style = \"font-family: Times New Roman;  text-align: center; color: hsl(210, 90%, 90%); font-size: 32px;\" transition:fade>\nA SIMPLE LITTLE MONAD\n \t</div>\n {/if}\n <br>\n<span class=\"tao\"> The word \"monad\" has been around for centuries. Gottfried Leibniz published </span>\n<span style = \"font-style: italic\"> Monadology </span>\n<span> in 1714. The precursor to the familiar symbol of yin-yang, taijitu (太極圖), has a version with two dots added, has been given the august designation: \"The Great Monad\". A single note in music theory is called a monad. All of this is too tangential to warrant references. I Googled around a little to get it and you can too if the word \"monad\" interests you.</span>\n<p> Monads in the Haskell Programming Language were inspired by Category Theory monads. In order to be Category Theory monads, function must exist in a mathematically rigorous \"category\". Haskells objects and functions are not the objects and morphisms of Category Theory. Making a category out of most of Haskell's functions and types is an amusing pasttime for some people, but I doubt that it has any practical value. </p>\n<p> So it should be no surprise that my JavaScript monads are not Category Theory monads. They do obey a JavaScript version of the Haskell monad laws, which are not a requirement in Haskell but are indicative of utility and robustness objects (including functions) don't constitute a category. But functions that hold values and compose with multiple functions that operate on their values behave like Category Theory monads enough to justify calling them \"monads\".</p>\n<p> Here's the definitions of three functions: </p>\n<pre>{monadDisplay}</pre>\n<p> And here is an anonymous monad followed by three functions and \"stop\". : </p>\n<pre> Monad(6)(sum(7))(prod(4))(v=>v-10)(stop) // 42 </pre>\n<p> Anonymous monads never interfere with other monads. The demonstration below illustrates this by running seven anonymous monads in rapid succession. The number you enter is \"num\" in </p>\n{bonadsD}\n<input id = \"one\" type = \"number\" on:input={bonads}  bind:value={num} />\n<p> num is {num} so bonads(num) returns {bonads(num)} </p>\n\n<span class = tao> Named monads retain their values, even after they encounter \"stop\" and return the value of x held in the Monad closure. The following examples illustrate this: </span>\n<pre>\n{axe}\n</pre>\n\n<p> As expected, mon returns which is the \"foo()\" returned by by calling Monad(3):</p>\n\n<p> mon is still the foo() returned by Monad(). Because mon points to x in the context of its creation by Monad(), x will not be garbage collected. Care should be taken not to polute memory with useless x's.</p>\n\n<p> One reason Svelte is so fast and efficient is that it mutates variables and the attributes and methods of objects. Each module in a discrete global space.  When modules are small, applications are easy to organize and mutations don't have unforseen effects in other parts of applications. Svelte shook off the bonds of current conventional \"wisdom\" advocating immutability, virtual DOM, and assigning types to functions. </p>\n<p> The next entry in the monad series defines a variation of Monad that maintains and array of primitive data, function return values, and Promise resolution values. Functions have access to everything in the array when they execute. </p>\n",
    "\n\n\n<script>\nimport {fade} from \"svelte/transition\"\nlet visible = true;\n\nlet GHC_IO = `module GHC.IO.Unsafe (\n    unsafePerformIO, unsafeInterleaveIO,\n    unsafeDupablePerformIO, unsafeDupableInterleaveIO,\n    noDuplicate,\n  ) where\n\nimport GHC.Base\n\nThis is a \\\"back door\\\" into the \\'IO\\' monad, allowing\\'IO\\' computation to be performed at any time.  For this to be safe, the \\'IO\\' computation should be free of side effects and independent of its environment.\n `\n</script>\n\n<style>\n\nh3 {\n    font-size: 27px;\n}\n#large {\n     font-size: 23px;\n     color: #aaddff;\n}\n</style>\n{#if visible}\n <div style = \"font-family: Times New Roman; text-align: center; color: hsl(210, 90%, 90%); font-size: 32px;\" transition:fade>\n <br><br>\nHASKELL TUTORIAL SUPPLEMENT\n </div>\n{/if}\n\n<p> If you are learning to program in Haskell, the book or blog or YouTube video on which you rely might be telling you that mutations can occur only inside of monads or somewhere away from a program such as the command line or a browser. You might be learning that mutations and side effects can occur only in the lazy IO monad. If so, don't believe it. You are being misled.  </p>\n<p> Even if you resent being lied to, you might find value in some of the dishonest learning resources. They are trying to teach best practices. Just know know that it is easy to mutate values and types anywhere in a Haskell program. Doing so before you know what your compiler (presumably GHC) will do with your mutations is asking for bugs and crashes.  Here are some unsafe functions with descriptions from their creators and maintainers: </p>\n<p id = large> Unsafe.Coerce </p>\n<p> The highly unsafe primitive unsafeCoerce converts a value from any type to any other type. Needless to say, if you use this function, it is your responsibility to ensure that the old and new types have identical internal representations, in order to prevent runtime corruption. </p>\n<span class = tao> The only function in this library is unsafeCoerce :: a -> b. You can read more about it at </span>\n<a href = \"http://hackage.haskell.org/package/base-4.12.0.0/docs/Unsafe-Coerce.html\" target = \"_blank\">Unsafe.Coerce</a>\n<br />\n<pre> GHC.IO.Unsafe </pre>\n<p> If the IO computation wrapped in \\'unsafePerformIO\\' performs side effects, then the relative order in which those side effects take place (relative to the main IO trunk, or other calls to \\'unsafePerformIO\\') is indeterminate.  Furthermore, when using \\'unsafePerformIO\\' to cause side-effects, you should take the following precautions to ensure the side effects are performed as many times as you expect them to be.  Note that these precautions are necessary for GHC, but may not be sufficient, and other compilers may require different precautions. </p>\n<span class = tao > For more information, go to </span>\n<a href = \"http://hackage.haskell.org/package/base-4.12.0.0/docs/src/GHC.IO.Unsafe.html\" target = \"_blank\"> GHC.IO.Unsafe </a>\n<br />\n<br />\n<span class = tao> And here\\'s a stub on the Haskell Wiki site that isn\\'t generating much interest: </span>\n<a href = \"https://wiki.haskell.org/Unsafe_functions\" target = \"_blank\" > More on GHC.IO.Unsafe </a>\n<span> along with a discussion of mutable global variables in Haskell programs: </span>\n<a href = \"https://wiki.haskell.org/Top_level_mutable_state\" target = \"_blank\"> Top level mutable state </a>\n"
  ],
  "names": [],
  "mappings": "AAoDE,EAAE,cAAC,CAAC,AAAE,OAAO,CAAE,KAAK,CACpB,WAAW,CAAE,IAAI,CACjB,YAAY,CAAE,IAAI,CAClB,KAAK,CAAE,GAAG,CACP,UAAU,CAAE,IAAI,AACnB,CAAC;ACgCH,IAAI,eAAC,CAAC,AACJ,WAAW,CAAE,EAAE,AACjB,CAAC;ACnED,MAAM,cAAC,CAAC,AACH,SAAS,CAAE,IAAI,CACf,KAAK,CAAE,OAAO,AACnB,CAAC"
}