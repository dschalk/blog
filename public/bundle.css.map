{
  "version": 3,
  "file": "bundle.css",
  "sources": [
    "../src/Blog.svelte",
    "../src/Monad6.svelte",
    "../src/Monad2.svelte",
    "../src/Monad3.svelte",
    "../src/Transducer.svelte"
  ],
  "sourcesContent": [
    "<script>\n\nexport let j = 0;\n\nimport Monad1 from './Monad1.svelte'\nimport Monad2 from './Monad2.svelte'\nimport Monad3 from './Monad3.svelte'\nimport Monad6 from './Monad6.svelte'\nimport Matrix from './Matrix.svelte'\nimport Transducer from './Transducer.svelte'\nimport Home from './Home.svelte'\nimport Score from './Score.svelte'\n\nfunction id (v) {return v}\n\n</script>\n\n    <style>\ndiv {\nfont-style: \"Times New Roman\";\n}\n\n.large {\n  font-size: 28px;\n  color: #ffffbb;\n  text-align: center;\n}\n\n.show {   \n  position: fixed;\n  top: 75px;\n  left: 10%;\n  width: 16%;\ndisplay: inline-block;\nbackground-color: #361B01;\nfont-size: 34px;\ncolor: #EEF7DD;\n}\n\n.stat {\n  position:  absolute;\n  top: 100px;\n  left: 80%;\n  width: 10%;\ndisplay: inline-block;\nbackground-color: #361B01;\ncolor: #CCFFCC;\nfont-size: 14px;\n}\n\n.dropbtn {\nbackground-color: #361B01;\ncolor: orange;\nfont-size: 27px;\nborder: none;\n}\n\n.dropdown {\n  position: fixed;\n  top: 115px;\n  left: 10%;\n  width: 16%;\ndisplay: inline-block;\nbackground-color: #361B01;\n}\n\n.dropdown3 {\n  position: fixed;\n  top: 300px;\n  left: 77%;\n  width: 16%;\ndisplay: inline-block;\nbackground-color: #361B01;\n}\n\n.dropdown-content {\nfont-size: 23px;    \ndisplay: none;\nposition: absolute;\ncolor: sky-blue;    \nz-index: 0;\nbackground-color: #361B01;\n}\n\n.dropdown3-content {\nfont-size: 23px;    \ndisplay: none;\nposition: absolute;\ncolor: sky-blue;    \nz-index: -1    ;\nbackground-color: #361B01;  \ndisplay: block;\ncolor: #DDFFBB      ; \n}\n\n.dropdown-content a:hover {color: gold; background-color: #361B01;}\n\n.dropdown:hover .dropdown-content {display: block; \n\nbackground-color:#361B01;}\n\n.dropdown3-content a:hover {color: gold; background-color: #361B01;}\n\n.dropdown3:hover .dropdown3-content {display: block; \n\nbackground-color:#361B01;}\n\n\n\n.dropbtn {color: gold; background-color: #361B01;}\n\n</style>\n<div style = \"font-size: 58px; color: gold; text-align: center\">Powerful JavaScript Monads</div>\n<div style = \"font-size: 32px; color: #FFBBBB; font-style:italic; text-align: center; margin-left: 27%; margin-right: 27%\" > Asynchronously linking functions, primitive values, promises, and objects of all types with recursive closures. </div> \n\n\n<div class = stat>\n<div>A Svelte front-end with a</div>\n<div>Haskell WebSockets server</div>\n<br>\n<div >David E. Schalk</div>  \n<div>fp3216@protonmail.com</div>\n<div>https://github.com/dschalk</div>\n</div>\n<div class=\"dropdown\">\n<br>\n  <div class=\"dropbtn\">Table of Contents</div>\n  <div class=\"dropdown-content\">\n  <br>\n<div class = menu on:click = {() => j = 0}> Home</div>\n  <br>\n<div class = menu on:click = {() => j = 1}> A Simple Monad</div>\n  <br>\n<div class = menu on:click = {() => j = 2}> A Messaging Monad</div>\n  <br>\n<div class = menu on:click = {() => j = 3}> A Promises Monad</div>\n  <br>\n<div class = menu on:click = {() => j = 4}> Transducer Monad</div>\n  <br>\n<div class = menu on:click = {() => j = 5}> Why Svelte</div>\n  <br>\n<div class = menu on:click = {() => j = 6}> Experiment</div>\n  <br>\n  <br></div>\n\n  </div>\n\n\n\n<div style = \"margin-left: 25%; margin-right: 25%;\">\n\n <br>\n\n{#if j === 0}\n<div class = show>Home</div>\n<Home />\n{/if}\n{#if j === 1}\n<div class = show>Simple Monad</div>\n<Monad1 />\n{/if}\n{#if j === 2}\n<div class = show>Messages Monad</div>\n<Monad2 />\n{/if}\n{#if j === 3}\n<div class = show>Promises Snownad</div>\n<Monad3 />\n{/if}\n{#if j === 4}\n<div class = show>Transducer Monad</div>\n<Transducer />\n{/if}\n{#if j === 5}\n<div class = show>Why Svelte</div>\n<Matrix />\n{/if}\n{#if j === 6}\n<div class = show>Monad6</div>\n<Monad6 />\n{/if}\n\n<br><br>\n<slot />\n\n<br><br>\n<br><br>\n<br><br>\n\n</div>\n\n",
    "\n<script>\nimport {fade} from \"svelte/transition\"\nlet visible = true;\n\nvar j  = 2;\n\n var s = \"stop\"; var h = \"halt\"; var c = \"clear\";\n\nlet GO = \"Cornucopia\";;\nvar koo;\nvar ko = [];\nvar jo = [];\nvar bo = []\n\nfunction ff (m) {\nko = []\nbo = m(s);\nvar ar = [...bo.keys()]\njo = m(h);\nkoo = [...bo.keys()].map(v =>ko.concat(`The prime fuctors of ${bo[v]} are ${jo[v]}`))\nko = koo.map(v => v[0]);\nGO = koo;\nreturn koo;\n}\n\nvar toInt = function toInt (a) {\n    if (Array.isArray(a)) return NaN; \n    else return parseInt(a, 10)\n};\n\nfunction Monad () { \n    var ar1 = [];\n    var ar2 = [];\n    var s = \"stop\"; var h = \"halt\"; \n    console.log(\"New Monad\");\n    function _f (func) {\n        if (func === \"stop\") return ar1\n        else if (func === \"halt\") return ar2\n        else if (func === \"clear\") {ar1 = []; ar2 = []}\n        else if (toInt(func) === toInt(func) && typeof func !== \"function\" ) {\n            ar1.push(func) \n        }\n        else if (Array.isArray(func)) ar2.push(func)\n        else if (typeof func ===\"function\") ar3.push (func(ar1))\n    } \n   return _f;\n}\n\nvar ace = Monad();\n\nvar worker_OO = new Worker('worker_OO.js');\n\nworker_OO.onmessage = function(e) {\n     ace(e.data); \n     ff(ace);\n};\n\n// var socket = new WebSocket(\"ws://localhost:3055\")\n// var socket = new WebSocket(\"ws://167.71.168.53:3055\")\nvar socket = new WebSocket(\"ws://schalk.net:3055\")\n\nsocket.onclose = function (event) {\nconsole.log('<><><> ALERT - socket is closing. <><><> ', event);\n};\n\nsocket.onmessage = function(e) {\n// console.log(\"WebSocket message is\", e);\nvar v = e.data.split(',');\nif (v[0] === \"BE#$42\") {\n    ace(v[3]);\n    worker_OO.postMessage([v[3]])\n}\n}\n\nlogin();\n\nfunction login() {\nconsole.log('00000000000000000000000000000000 Entering login', socket.readyState);\nsetTimeout(function () {\nif (socket.readyState === 1) {\n  console.log('readyState is', socket.readyState);\n  var v = Math.random().toString().substring(5);\n  var v2 = v.toString().substring(2);\n  var combo = v + '<o>' + v2;\n  socket.send('CC#$42' + combo);\n  factors();\n  // socket.send(`GZ#$42,solo,${v}`);\n} else {\n  login();\n}\n}, 200)\n}\n\nfunction factors () {\n  ace(\"clear\")\n  socket.send(\"BE#$42,solo,name,10000\"); \n  socket.send(\"BE#$42,solo,name,100000\"); \n  socket.send(\"BE#$42,solo,name,1000  \"); \n  socket.send(\"BE#$42,solo,name,100000\"); \n  socket.send(\"BE#$42,solo,name,10000  \"); \n}  \n\nvar btn = `ace('clear')\nsocket.send(\"BE#$42,solo,name,10000\")\nsocket.send(\"BE#$42,solo,name,100000\")\nsocket.send(\"BE#$42,solo,name,1000 \")\nsocket.send(\"BE#$42,solo,name,100000\")\nsocket.send(\"BE#$42,solo,name,10000 \")`\n\n\n</script>\n\n<style>\nbutton {\ntext-align: left;\nbackground-color: #004400;\nborder-width: 2px;\nborder-color: #E8F7C1;\nborder-radius: 70px;\ntext-decoration-color: red;\nfont-size: 20px;\n\n-webkit-box-shadow: 0px 0px 15px 0px rgb(255, 215, 0);\nbox-shadow:         0px 0px 15px 0px rgb(255, 215, 0);\npadding: 3px 10px 3px 10px;\n}\n\nbutton:hover {\nbackground-color: #0000CC;\npadding: 3px 10px 3px 10px;\ntext-decoration-color: yellow;\nborder-color: #0000AA;\n}\n</style>\n<br><br>\n{#if j === 2} \n<div style = \"font-family: Times New Roman;  text-align: center; color: hsl(210, 90%, 90%); font-size: 38px;\" transition:fade>\nASYNCHRONOUSLY MODIFIED STATE\n</div>\n{/if}\n<br>\n<p> Clicking the button below sends three requests to the server asking for quasi-random integers. </p> \n<div style = \"font-size: 28; margin-left: 130px; color: #EECCFF\">\n {GO[0]}\n<br>\n {GO[1]}\n<br>\n {GO[2]}\n<br>\n {GO[3]}\n<br>\n {GO[4]}\n </div>\n<br>\n<button on:click = {factors} >\n  <pre>{btn}</pre>\n</button>\n\n<br>\n\n<p> Messages sent to the Haskell WebSockets server with prefix BE#$42 are requests for pseudo-random integers between 1 and an upper bound.specified at the end of each request.  The server sends a message back to the browser prefixed by \"BE#$42\" and ending with the requested pseudo-random number.  That number is extracted from the message in socket.onmessage and sent to a Web Worker named worker_OO. which returns a message containing the pseudo-random number's prime factors.  </p>\n\n\n\n",
    "\n<script>\nimport {fade} from \"svelte/transition\"\nlet visible = true;\n\nvar O = {};\nvar test_2 = function test_2 () {};\nvar name = \"Mandy\";\nO[\"Mandy\"] = [23];\n\nfunction wait(ms) {\nreturn new Promise(r => setTimeout(r, ms));\n}\n\nlet j = 2;\n$: j;\n\nasync function pause (x) {\nawait wait(1000)\nreturn x;\n}\n\nvar pauseP = t => async x => {\nawait wait(t*1000)\nreturn x;\n}\n\nasync function pauseM (x) {\nawait wait(600)\nreturn Monad(x);\n}\n\nasync function pauseX (x) {\nawait wait(x);\n}\n\nasync function squareP (x) {\nawait wait(1200)\nreturn x*x;\n}\n\nvar divPinverse = a => async b => {\nawait wait (600)\nreturn a/b;\n}\n\nvar divP = a => async b => {\nawait wait (600)\nreturn b/a;\n}\n\nvar doubleP = async a => {\nawait wait (1000)\nreturn a+a;\n}\n\nvar toInt = a => parseInt(a, 10);\n\nvar addP_toInt = x => async y => {\nawait wait(1000)\nreturn toInt(x) + toInt(y);\n}\n\nvar addP = x => async y => {\nawait wait(1000)\nreturn x + y;\n}\n\nvar multP = x => async y => {\nawait wait(1200)\nreturn x * y;\n}\n\nvar powP = x => async y => {\nawait wait(1200)\nreturn y**x;\n}\n\nasync function cubeP (x) {\nawait wait(1200)\nreturn x*x*x;\n}\n\nasync function idP (x) {\nawait wait(1200)\nreturn x;\n}\nasync function sqrtP (x) {\nawait wait(1200)\nreturn x**(1/2)\n}\n\nfunction intArray (n) {\nreturn [...Array(n).keys()];\n}\n\nvar cube = x => x**3;\nvar pow = p => x => x**p;\nvar square = x => x*x;\nvar add = x => y => x+y;\nvar sqrt = x => x**(1/2);\nvar root = r => x => x(1/r);\nvar div = d => x => x/d;\n\nvar f = function f () {};\nvar f_ = function f_ () {};\nvar sto = \"sto\";\nvar halt = \"halt\";\n\nvar O = new Object();\nO.d0 = [2,3,4];\nO.d1 = [2,3,4];\nO.d2= [2,3,4];\n\nvar M = -1;\nvar Q = -1\n\nvar lock = false;\n\nO.generic = [\"Nobody\"];\n\nconst  Monad =function Monad ( AR = [],  name = \"generic\" )  {\nvar x = AR.pop();\nO[name] = AR;\nvar s = \"stop\";\n (function run (xx) {\nif (typeof xx != \"undefined\"  && xx === xx  && xx !== false && xx.name !== \"f_\" && xx.name !== \"stop\" )  {\n  O[name] = O[name].concat(xx)\n};\nvar  f_ = function f_ (func) {\n    if (func === 'stop'  || func === 's') return O[name]\n    else if (typeof func !== \"function\") p = func(x)\n    else if (x instanceof Promise) p = x.then(v => func(v));\n    return run(p);\n  }\n  return f_;\n}) (x);\n} \n\n\nvar cow = Monad([], \"cow\")\nconsole.log(\"cow is\", cow);\n\n// var socket = new WebSocket(\"ws://localhost:3055\")\nvar socket = new WebSocket(\"ws://167.71.168.53:3055\")\n\nsocket.onclose = function (event) {\nconsole.log('<><><> ALERT - socket is closing. <><><> ', event);\n};\n\nsocket.onmessage = function(e) {\n// console.log(\"WebSocket message is\", e);\nvar v = e.data.split(',');\nif (v[0] === \"BE#$42\") {\nQ = Q + 1;\nMonad([v[3]], \"c\"+Q);\nif (Q === 2) Q = -1;\nworker_OO.postMessage([v[3]])\n}\n}\n\nlogin();\n\nfunction login() {\nconsole.log('00000000000000000000000000000000 Entering login', socket.readyState);\nsetTimeout(function () {\nif (socket.readyState === 1) {\n  console.log('readyState is', socket.readyState);\n  var v = Math.random().toString().substring(5);\n  var v2 = v.toString().substring(2);\n  var combo = v + '<o>' + v2;\n  socket.send('CC#$42' + combo);\n  // socket.send(`GZ#$42,solo,${v}`);\n  socket.send(\"BE#$42,solo,name,10000\")\n  socket.send(\"BE#$42,solo,name,100000\")\n  socket.send(\"BE#$42,solo,name,1000\")\n} else {\n  login();\n}\n}, 200)\n}\n\nfunction isEmpty(obj) {\nfor(var key in obj) {\n    if(obj.hasOwnProperty(key))\n        return false;\n}\nreturn true;\n};\n\nfunction countKeys(ob, s) {\nvar N = 0\nfor(var key in ob) if (key.startsWith(s)) N+=1;\nreturn N;\n}\n\nvar groupDelete = function groupDelete (ob, x) {\nfor (var z in ob) if (z.startsWith(\"x\")) delete ob[z]\n}\n\nvar clearOb = function clearOb (ob) {\nfor (var x in ob) delete ob[x]\n}\n\nvar factors = function factors () {\nsocket.send(\"BE#$42,solo,name,10000\")\nsocket.send(\"BE#$42,solo,name,100000\")\nsocket.send(\"BE#$42,solo,name,1000\")\n}\n\nvar worker_OO = new Worker('worker_OO.js');\n\nworker_OO.onmessage = e => {\nM = M + 1;\nMonad([e.data], \"d\"+M);\nif (M === 2) {\n  M = -1;\n}\n}\n\nvar mon = `const  Monad =function Monad ( AR = [],  name = \"generic\" )  {\n    var x = AR.pop(); // x will be replaced in the function \"run\" (below)\n    O[name] = AR;\n    var s = \"stop\";\n    (function run (xx) {\n        if (typeof xx != \"undefined\"  && xx === xx  && xx !== false && \n        xx.name !== \"f_\" && xx.name !== \"stop\" )  {\n            O[name] = O[name].concat(xx)\n        };\n        var  f_ = function f_ (func) {\n            if (func === 'stop'  || func === 's') return O[name]\n            else if (typeof func !== \"function\") p = func(x)\n            else if (x instanceof Promise) p = x.then(v => func(v));\n            return run(p);\n        }\n        return f_;\n    }) (x);\n}  `\n\nvar statement = `    Monad([\"value\"], \"key\")(x => \"This is the \" + x)(x => x + \".\")(halt)\nO.key   // [\"value\", \"This is the value\", \"This is the value.\"]`\n\nvar fa = `    function factors () {\nif (lock === false && j === 2) {\nlock = true;\nclearOb(O);\nN = -1;\nM = -1;\nQ = -1;\ngroupDelete(O, \"c\");\ngroupDelete(O, \"d\");\nfact();\n}\nelse if (j !== 2) {return}\nelse {\nsetTimeout(()=> {\nfactors()\n},1000)\n}\n}`\n\nvar onmessServer = `ar v = e.data.split(',');\nif (v[0] === \"BE#$42\") {\nQ = Q + 1;\nMonad([v[3]], \"c\"+Q);\nworker_OO.postMessage([v[3]])\n}\n}  `\n\nvar onmessWorker = `worker_OO.onmessage = e => {\nM = M + 1;\nMonad([e.data], \"d\"+M);\nif (M === 2) {\n  M = -1;\n}\n}`\n\nlet candle = ` socket.send(\\\"BE#$42,solo,name,10000\\\")    \nsocket.send('\\BE#$42,solo,name,100000\\\")    \nsocket.send(\\\"BE#$42,solo,name,1000\\\")    `    \n\n\n</script>\n\n<style>\nbutton {\nmargin-left: 5%i;\nbackground-color: #004400;\nborder-width: 2px;\nborder-color: #E8F7C1;\nborder-radius: 70px;\ntext-decoration-color: red;\nfont-size: 20px;\n-webkit-box-shadow: 0px 0px 15px 0px rgb(255, 215, 0);\nbox-shadow:         0px 0px 15px 0px rgb(255, 215, 0);\npadding: 3px 10px 3px 10px;\n}\n\nbutton:hover {\nbackground-color: #0000CC;\npadding: 3px 10px 3px 10px;\ntext-decoration-color: yellow;\nborder-color: #0000AA;\n}\n\n</style>\n<br><br>\n{#if j === 2} \n<div style = \"font-family: Times New Roman;  text-align: center; color: hsl(210, 90%, 90%); font-size: 38px;\" transition:fade>\nASYNCHRONOUSLY MODIFIED STATE\n</div>\n{/if}\n\n<br>\n<p> Clicking the button below sends three requests to the Haskell WebSockets server asking for quasi-random integers. As the numbers come in from the server, they are placed in the object named \"O\" with keys prefixed by \"c\", and then forwarded to a web worker. The worker returns arrays containing the prime factors of the numbers it recieves. These are placed in \"O\" with keys prefixed by \"d\".</p> \n<br>\n<div style = \"color: #BBBBFF; font-size: 20px;\"> The WebSockets server sent these numbers (now at O.c0, O.c1, and O.c2): </div>\n<div style = \"color: #FFFFCD; font-size: 20px; \">\n{O.c0}, {O.c1}, and {O.c2}  \n</div>\n<br>\n<span style = \"color: #CDCDFF; font-size: 20px;\"> The web worker sent these arrays of prime factors (now at O.d0, O.d1, and O.d2): </span>\n<span style = \"color: #FFFFCD; font-size: 20px;\">\n<br> [{O.d0.join(', ')}] <br> [{O.d1.join(', ')}] <br> [{O.d2.join(', ')}]</span>;\n<br>\n<br>\n<button on:click = {factors}>\n<pre>{candle}</pre>\n\n</button>\n<br><br><br>\n\n<div style = \"color: #FFFFCD; font-size: 20px;\">\n[{O.d0}].reduce((a,b) => a*b) === {O.c0}: <span style = \"font-size:24px; color:#FF0B0B\" >{O.d0.reduce((a,b) => a*b) == O.c0}</span>\n<br>\n[{O.d1}].reduce((a,b) => a*b) === {O.c1}: <span style = \"font-size:24px; color:#FF0B0B\" >{O.d1.reduce((a,b) => a*b) == O.c1}</span>\n<br>\n[{O.d2}].reduce((a,b) => a*b) ==  = {O.c2}: <span style = \"font-size:24px; color:#FF0B0B\" >{O.d2.reduce((a,b) => a*b) == O.c2}</span>\n<br>\n\n\n</div>\n\n<p> In this demonstration, each monad's array of computed values is preserved as an attribute of an object named O. Here's the definition of \"Monad\" used in this module:</p>\n\n<pre>{mon}</pre>\n\n<p> Messages are sent to the Haskell WebSockets server requesting pseudo-random numbers between 1 and the integer specified at the end of the request. On the server, randomR from the System.Random library produces a number which is sent to the browser with prefix \"BE#$42\". Messages from the server are parsed in socket.onmessage. If the prefix is \"BE#$42\", the payload (a number) is sent to worker_OO, which sends back the number's prime decomposition.\n<pre>{onmessServer}</pre>\n<p> Messages from the web worker are processed in worker_OO.onmessage\n<pre>{onmessWorker}</pre>\n<p> When M === 2 the process is complete. M and N are set to -1 and lock is set to false, allowing another possible call to random() to call rand(). </p>\n<br>\n<span> The code for this Svelte application is at </span>\n<a href = \"https://github.com/dschalk/blog/\" target = \"_blank\">GitHub repository</a>\n",
    "\n  <script>  \n      import {fade} from \"svelte/transition\"\n        let j = 3;\n        $: j;\n\n\nfunction wait(ms) {\nreturn new Promise(r => setTimeout(r, ms));\n}\n\nasync function pause (x) {\n  await wait(1000)\n  return x;\n}\n\nlet pauseP = t => async x => {\n  await wait(t*1000)\n  return x;\n}\n\nasync function pauseM (x) {\n  await wait(600)\n  return ret(x);\n}\n\nasync function pauseX (x) {\n  await wait(x);\n}\n\nasync function squareP (x) {\n  await wait(300)\n  return x*x;\n}\n\nlet divPinverse = a => async b => {\n  await wait (300)\n  return a/b;\n}\n\nlet divP = a => async b => {\n  await wait (300)\n  return b/a;\n}\n\nlet doubleP = async a => {\n  await wait (300)\n  return a+a;\n}\n\nlet toInt = a => pareseInt(a, 10);\n\nlet addP_toInt = x => async y => {\n  await wait(300)\n  return toInt(x) + toInt(y);\n}\n\nlet addP = x => async y => {\n  await wait(900)\n  return parseInt(x,10) + parseInt(y,10);\n}\n\nlet multP = x => async y => {\n  await wait(300)\n  return x * y;\n}\n\nlet powP = x => async y => {\n  await wait(300)\n  return y**x;\n}\n\nasync function cubeP (x) {\n  await wait(300)\n  return x*x*x;\n}\n\nasync function idP (x) {\n  await wait(900)\n  return x;\n}\nasync function sqrtP (x) {\n  await wait(900)\n  return x**(1/2)\n}\n\nlet _conveNt_ = a => b => parseFloat(b,a);\nlet toFloat = _conveNt_ (10);\n\nlet cube = x => x**3;\nlet pow = p => x => x**p;\nlet square = x => x*x;\nlet add = x => y => parseInt(x) + parseInt(y);\nlet sqrt = x => x**(1/2);\nlet root = r => x => x(1/r);\nlet mult = a => b => a*b;\nlet div = d => x => x/d;\n\nlet f = function f () {};\nlet f_ = function f_ () {};\nlet sto = \"sto\";\nlet halt = \"halt\";\n\nlet lock = false;\n$: lock\n\nlet h = \"halt\"\n\nconst sym1 = Symbol('sym1');\nconst sym2 = Symbol('sym2');\nconst sym3 = Symbol('sym3');\n\nlet B = {};\nB[sym1] = [];\nB[sym2] = [];\nB[sym3] = [];\n\nlet Mona = function Mona ( AR = [],  ar = \"name\" )  {  \n  let p, run, f_;\n  B[ar] = AR.slice();\n  let x = B[ar].slice(-1)[0] ;\n  return run = (function run (x) {\n  if (x instanceof Promise) {x.then(y => {\n    if (!( y.name == \"f_\" || y == lok || y == NaN || y == undefined ||\n      typeof y == \"undefined\" || y != y  ) ){B[ar] = B[ar].concat(y)}\n    else if (!(x.name == \"f_\" || x == lok || x instanceof Promise ||\n      x == undefined || x == NaN)) {B[ar] = B[ar].concat(x);\n  }   }  )  }\n    f_ = function f_ (func) {\n      console.log(\"B[ar] is\", B[ar]);\n      if (func === 'halt' || func === 'h' || func == undefined ||\n        typeof func == \"undefined\" || func == NaN ) {\n        B[ar] = B[ar]; \n        return B[ar].slice();\n      }\n      if (typeof func == \"function\" && x instanceof Promise) p = x.then(v => func(v))\n      else if (typeof func != \"function\" && x instanceof Promise) p = x.then(v => v)\n      else if (typeof func != \"function\") p = func\n      else p = func(x);\n      return run(p);\n    };\n    return f_;\n  })(x);\n}\n\n  const A = {};\n\n  A[sym1] = Mona([0], sym1);\n  A[sym2] = Mona([], sym2);\n  A[sym3] = Mona([], sym3);\n\nfunction test_3 () {\n  lok = true;\n  A[sym1] = Mona([0], sym1);\n  A[sym2] = Mona( [], sym2);\n  A[sym3] = Mona([], sym3);\n  A[sym1](addP(3))(cubeP)(addP(3))(squareP)(divP(100))(() => \n    branch(sym2,sym1)(idP)(squareP)(divP(27))(multP(7))(doubleP)(() => \n      branch(sym3,sym2)(idP)(() => B[sym1][1]+B[sym1][2]+B[sym1][3])\n      (divP(10))(multP(7))(()=>2+3+4+5)(multP(3))(() => \n        branch(sym1,sym2)(divP(7))(addP(8))(multP(3))\n        (() => B[sym1].reduce((a,b) => a+b))\n        (addP(-23))(divP(24))(() => lok = false)\n      )\n    )\n  )  \n}\n\nfunction branch (a, b) {  // Transfers a copy of the last item in A[b] to A[a]\n  let c = A[b]().slice(-1);\n  return A[a](c);\n}\n\nlet lok = false;\n$: lok;\n\nfunction start () {\n  if (!lok) {\n    console.log(\"lok is false -- calling test_3\")\n    test_3()\n  }\n  else {\n    console.log(\"lok is true -- setTimeout 300\")\n    setTimeout(() => start(),300);\n  }\n}\n\nfunction resume (s) {return branch(s,s)}\nstart();\n\n// let resume = function resume (s) {return Mona(A[s])}\n\nlet syms = `const sym1 = Symbol('sym1');\nconst sym2 = Symbol('sym2');\nconst sym3 = Symbol('sym3');`\n\nlet t_3 = `function test_3 () {\n  lok = true;\n  A[sym1] = Mona([0], sym1);\n  A[sym2] = Mona( [], sym2);\n  A[sym3] = Mona([], sym3);\n  A[sym1](addP(3))(cubeP)(addP(3))(squareP)(divP(100))(() => \n    branch(sym2,sym1)(idP)(squareP)(divP(27))(multP(7))(doubleP)(() => \n      branch(sym3,sym2)(idP)(() => B[sym1][1]+B[sym1][2]+B[sym1][3])\n      (divP(10))(multP(7))(()=>2+3+4+5)(multP(3))(() => \n        branch(sym1,sym2)(divP(7))(addP(8))(multP(3))(() => B[sym1].reduce((a,b) => a+b))\n        (addP(-23))(divP(24))(() => lok = false)\n      )\n    )\n  )  \n} `\nlet code = `let B = {};\nB[sym1] = [];\nB[sym2] = [];\nB[sym3] = [];\n\n$: B;\n\n  const A = {};\n  \nlet Mona = function Mona ( AR = [],  ar = \"name\" )  {  \n  let p, run, f_;\n  B[ar] = AR.slice();\n  let x = B[ar].slice(-1)[0] ;\n  return run = (function run (x) {\n  if (x instanceof Promise) {x.then(y => {\n    if (!( y.name == \"f_\" || y == lok || y == NaN || y == undefined ||\n      typeof y == \"undefined\" || y != y  ) ){B[ar] = B[ar].concat(y)}\n    else if (!(x.name == \"f_\" || x == lok || x instanceof Promise ||\n      x == undefined || x == NaN)) {B[ar] = B[ar].concat(x);\n  }   }  )  }\n    f_ = function f_ (func) {\n      console.log(\"B[ar] is\", B[ar]);\n      if (func === 'halt' || func === 'h' || func == undefined ||\n        typeof func == \"undefined\" || func == NaN ) {\n        B[ar] = B[ar]; \n        return B[ar].slice();\n      }\n      if (typeof func == \"function\" && x instanceof Promise) p = x.then(v => func(v))\n      else if (typeof func != \"function\" && x instanceof Promise) p = x.then(v => v)\n      else if (typeof func != \"function\") p = func\n      else p = func(x);\n      return run(p);\n    };\n    return f_;\n  })(x);\n}\n\n  A[sym1] = Mona([0], sym1);\n  A[sym2] = Mona([], sym2);\n  A[sym3] = Mona([], sym3);\n\n  $: B[sym1];\n  $: B[sym2];\n\nfunction test_3 () {\n  lok = true;\n  A[sym1] = Mona([0], sym1);\n  A[sym2] = Mona( [], sym2);\n  A[sym3] = Mona([], sym3);\n  A[sym1](addP(3))(cubeP)(addP(3))(squareP)(divP(100))(() => \n    branch(sym2,sym1)(idP)(squareP)(divP(27))(multP(7))(doubleP)(() => \n      branch(sym3,sym2)(idP)(() => B[sym1][1]+B[sym1][2]+B[sym1][3])\n      (divP(10))(multP(7))(()=>2+3+4+5)(multP(3))(() => \n        branch(sym1,sym2)(divP(7))(addP(8))(multP(3))\n        (() => B[sym1].reduce((a,b) => a+b))\n        (addP(-23))(divP(24))(() => lok = false)\n      )\n    )\n  )  \n}\n\ntest_3 ();\n\nfunction branch (a, b) {  // Transfers a copy of the last item in A[b] to A[a]\n  let c = A[b]().slice(-1);\n  return A[a](c);\n}\n\nlet lok = false;\n$: lok;`\nlet funcs = `function wait(ms) {\nreturn new Promise(r => setTimeout(r, ms));\n}\n\nasync function pause (x) {\n  await wait(1000)\n  return x;\n}\n\nlet pauseP = t => async x => {\n  await wait(t*1000)\n  return x;\n}\n\nasync function pauseM (x) {\n  await wait(600)\n  return ret(x);\n}\n\nasync function pauseX (x) {\n  await wait(x);\n}\n\nasync function squareP (x) {\n  await wait(300)\n  return x*x;\n}\n\nlet divPinverse = a => async b => {\n  await wait (300)\n  return a/b;\n}\n\nlet divP = a => async b => {\n  await wait (300)\n  return b/a;\n}\n\nlet doubleP = async a => {\n  await wait (300)\n  return a+a;\n}\n\nlet toInt = a => pareseInt(a, 10);\n\nlet addP_toInt = x => async y => {\n  await wait(300)\n  return toInt(x) + toInt(y);\n}\n\nlet addP = x => async y => {\n  await wait(900)\n  return parseInt(x,10) + parseInt(y,10);\n}\n\nlet multP = x => async y => {\n  await wait(300)\n  return x * y;\n}\n\nlet powP = x => async y => {\n  await wait(300)\n  return y**x;\n}\n\nasync function cubeP (x) {\n  await wait(300)\n  return x*x*x;\n}\n\nasync function idP (x) {\n  await wait(900)\n  return x;\n}\nasync function sqrtP (x) {\n  await wait(900)\n  return x**(1/2)\n}`\n  </script>\n\n  <style>\n\nbutton {\nmargin-left: 5%;\nbackground-color: #004400;\nborder-width: 2px;\nborder-color: #E8F7C1;\nborder-radius: 70px;\ntext-decoration-color: red;\nfont-size: 26px;\n-webkit-box-shadow: 0px 0px 15px 0px rgb(255, 215, 0);\nbox-shadow:         0px 0px 15px 0px rgb(255, 215, 0);\npadding: 3px 10px 3px 10px;\n}\n\nbutton:hover {\n  color: rgb(156, 236, 156);\n  background-color: #0000CC;\n  padding: 3px 10px 3px 10px;\n  text-decoration-color: yellow;\n   border-color: #0000AA;\n}\n\npre:hover {\n  color: gold;\n}\n\n.caption {\n  font: times;  \n  text-align: center; \n  color: hsl(210, 90%, 90%); \n  font-size: 32px;\n}\n\n.sub_caption {\n  font: times;  \n  text-align: center; \n  color: hsl(210, 90%, 90%); \n  font-size: 32px;\n}\n  </style>\n\n  {#if j === 3}\n <div style = \"font-family: Times New Roman;  text-align: center; color: hsl(210, 90%, 90%); \" transition:fade>\n<div style = \"font-size: 32px;\"> PROMISE MANIPULATION</div>\n<div style = \"font-size: 22px;\">Accessing Prior Resolution Values</div>  \n</div>\n{/if}\n  <br>\n\n<div style = \"font-style:italic; color: #FFCC00; \">NOTE: If you select a link in the table of contents while computations are in progress, the result might be displayed beneath what you see here. </div> \n\n<br>\n<p> If you click the button (below) while computations are in progress, test_3 will run again after the current run completes. The \"loc\" feature - which allows execution to begin only when loc === false - facilitates queueing any number of runs of test_3.    </p> \n<button style = \"text-align: left\" on:click = {start}>  \ntest_3 ()\n</button>\n\n<h3>lok is {lok}</h3>\n<h3> B[sym1] is {B[sym1]} </h3>\n<h3> B[sym2] is {B[sym2]} </h3>\n<h3> B[sym3] is {B[sym3]} </h3>\n\n<pre style = \"font-size: 18\">{syms}</pre>\n<pre style = \"font-size: 18\">{t_3}</pre> \n<pre style = \"font-size: 18\">{code}</pre>\n<pre style = \"font-size: 18\">{funcs}</pre>\n\n  <br>\n  <p></p>\n  <br> ",
    "<script>\nimport {fade} from \"svelte/transition\"\nlet visible = true;\n\n\nlet k  = 100000000;\n$: k;\nlet ltTest = x => y => new Filt(x => y < x);\n$: ltTest;\n\nlet isOdd = function isOdd (x) {return new Filt(v => v % 2 === 1)};\nlet _fives = function _fives (x) {\n if (typeof x === \"number\") {return new Filt(v => v % 10 === 5)}\n else if (typeof x === \"string\") {return Filt(v = v(v.length - 1))}\n else {return undefined}''\n}\n\nlet fives = function fives (x) {return new Filt(v => v % 10 === 5)}\n\nlet isOddF = function isOddF (x) {return new Filt(v => v % 2 === 1)};\n\nfunction isOd_ (x) {return new Filt(v => v % 2 === 1)};\nlet lessThan = x => y => new Filt(x => y < x);\n\nfunction tdReduce(base) {\n  return function(reducingFunction) {\n    return (accumulator, value) => {\n      return reducingFunction(accumulator, func(v));\n    }\n  }\n}\n\nfunction tdMap(func) {\n  return function(reducingFunction) {\n    return (accumulator, v) => {\n      return reducingFunction(accumulator, func(v));\n    }\n  }\n}\n\nfunction tdFilter(test) {\n  return function(reducingFunction) {\n    return (accumulator, v) => {\n      return (test(v) ? reducingFunction(accumulator, v) : accumulator)\n    };\n  };\n};\n\nlet ar = \"cowgirl\";\n$: ar;\n\nlet cleanF = function cleanF (arthur = []) {\n  ar = arthur;\n  return ar.filter(\n    a => a === 0 || a && typeof a !== \"boolean\" //\n  ).reduce((a,b)=>a.concat(b),[])\n};\n\n$: cleanF;\n\n\nfunction Monad ( AR = [] )  {\n  let f_, p, run;\n  let ar = AR.slice();\n  let x = ar.pop();\n  return run = (function run (x) {\n    if (x === null || x === NaN ||\n      x === undefined) x = f_('stop').pop();\n    if (x instanceof Filt) {\n      let z = ar.pop();\n      if (x.filt(z)) x = z; else ar = [];\n    }\n    else if (x instanceof Promise) x.then(y =>\n      {if (y != undefined && typeof y !== \"boolean\" && y === y &&\n      y.name !== \"f_\" &&\n      y.name !== \"stop\" ) {\n      ar.push(y);\n    }})\n    else if (x != undefined && x === x  && x !== false\n      && x.name !== \"f_\" && x.name !== \"stop\" ) {\n      ar.push(x);\n    };\n    function f_ (func) {\n      if (func === 'stop' || func === 'S') return ar;\n      else if (func === 'finish' || func === 'F') return Object.freeze(ar);\n      else if (typeof func !== \"function\") p = func;\n      else if (x instanceof Promise) p = x.then(v => func(v));\n      else p = func(x);\n      return run(p);\n    };\n\n    return f_;\n  })(x)\n}\n\nlet mon44 = `function Monad ( AR = [] )  {\n  let f_, p, run;\n  let ar = AR.slice();\n  let x = ar.pop();\n  return run = (function run (x) {\n    if (x === null || x === NaN ||\n      x === undefined) x = f_('stop').pop();\n    if (x instanceof Filt) {\n      let z = ar.pop();\n      if (x.filt(z)) x = z; else ar = [];\n    }\n    else if (x instanceof Promise) x.then(y =>\n      {if (y != undefined && typeof y !== \"boolean\" && y === y &&\n      y.name !== \"f_\" &&\n      y.name !== \"stop\" ) {\n      ar.push(y);\n    }})\n    else if (x != undefined && x === x  && x !== false\n      && x.name !== \"f_\" && x.name !== \"stop\" ) {\n      ar.push(x);\n    };\n    function f_ (func) {\n      if (func === 'stop' || func === 'S') return ar;\n      else if (func === 'finish' || func === 'F') return Object.freeze(ar);\n      else if (typeof func !== \"function\") p = func;\n      else if (x instanceof Promise) p = x.then(v => func(v));\n      else p = func(x);\n      return run(p);\n    };\n\n    return f_;\n  })(x)\n} `\n\nlet compose = (...fns) =>\nfns.reduceRight((prevFn, nextFn) =>\n(...args) => nextFn(prevFn(...args)),\nvalue => value\n);\n\nlet add1 = function add1(v) { return v + 1; };\nlet sum = function sum(total,v) { return total + v; };\nlet cube = function cube(v) { return v**3; };\n\nlet size = 100;\n$: size;\n\nlet ar74 = [...Array(size).keys()];\n$: ar74;\n\nlet mapWRf = mapping(cube);\nlet mapRes = ar74.reduce(mapWRf(concat), []);\n\nlet isEven = x => x % 2 === 0;\nlet not = x => !x;\nlet isOdd2 = compose(not, isEven);\n\nfunction curry(fn) {\n   let arity = fn.length;\n   return function $curry(...args) {\n      if (args.length < arity) {\n         return $curry.bind(null, ...args);\n      }\n      return fn.call(null, ...args);\n   }  ;\n}\n\nlet map = f => ar => ar.map(v=>f(v));\nlet filter = p => ar => ar.filter(p);\nlet reduce = f => ar => v => ar.reduce(f,v)\nfunction apply(x, f) {return f(x);}\nfunction concat(xs, val) {return xs.concat(val);}\n\nfunction mapping(f) {\n   return function(rf) {\n      return (acc, val) => {\n         return rf(acc, f(val));\n      }\n   }\n}\n\nlet A_A = \"H\";\n$: A_A;\n\nlet B_B = \"s\";\n$: B_B;\n\nlet C_C = \"G\";\n$: C_C;\n\nlet D_D = \"I\";\n$: D_D;\n\nlet res1;\n// $: res1;\n\nlet res2;\n// $: res2;\n\nlet res3;\n$: res3;\n\nlet res4;\n$: res4;\n\nlet dotResult = [];\n$: dotResult;\n\nlet test9;\n$: test9;\n\nlet transducerResult;\n$: transducerResult;\n\n\n A_A = dotResult = ar74\n   .filter(v => (v % 2 === 1))\n   .map(x => x**4)\n   .map(x => x+3)\n   .map(x => x-3)\n   .filter(v => v % 10 === 5)\n   .map(x => Math.sqrt(x))\n   .map(v=>v*v)\n   .map(v=>v+1000)\n\n\nlet td3;\n$: td3;\n\nlet xform;\n$: xform;\n\nlet xform2;\n$: xform2;\n\nlet xform3;\n$: xform3\n\n\nlet test8 = k => ltTest(k).filt;;\n\n  function Filt (p) {this.p = p; this.filt = function filt (x) {return p(x)}};\n\n  let td1 = x => Monad([x])(isOdd)(v=>v**4)(v=>v+3)(v=>v-3)(fives)(Math.sqrt)('stop').pop()\n  let td2 = y => Monad([y])(v=>v*v)(v=>v+1000)('stop').pop()\n\nres1 = ar74.map(x => td1(x));\nB_B = res2 = res1.map(y => td2(y));\nC_C = res3 = ar74.map(z => td2(td1(z)));\n\n\n   xform = compose(\n      tdFilter(x=>x%2===1),\n      tdMap(x => x**4),\n      tdMap(x => x+3),\n      tdMap(x => x-3),\n      tdFilter(x => x % 10 === 5),\n      tdMap(x => Math.sqrt(x))\n   )\n   xform2 = compose(\n      tdMap(x=>x*x),\n      tdMap(x=>x+1000)\n   );\n\n   xform3 = compose(\n      tdFilter(x=>x%2===1),\n      tdMap(x => x**4),\n      tdMap(x => x+3),\n      tdMap(x => x-3),\n      tdFilter(x => x % 10 === 5),\n      tdMap(x => Math.sqrt(x)),\n      tdMap(x=>x*x),\n      tdMap(x=>x+1000)\n   );\n   D_D = transducerResult = ar74.reduce(xform3(concat),[] );\n   $: transducerResult = ar74.reduce(xform3(concat),[] );\n\n   $: A_A = dotResult;\n   $: B_B = cleanF(res2);\n   $: C_C = cleanF(res3);\n   $: D_D = transducerResult;\n\nlet t37;\n$: t37;\nfunction test37 (e) {t37 = e; console.log(e)};\n\n\n$: dotResult;\n$: res2;\n$: res3;\n$: transducerResult;\n\nlet callback = `function increase () {\n  size = size + 10;\n  ar74 = [...Array(size).keys()];\n   A_A = dotResult = ar74\n   .filter(v => (v % 2 === 1))\n   .map(x => x**4)\n   .map(x => x+3)\n   .map(x => x-3)\n   .filter(v => v % 10 === 5)\n   .map(x => Math.sqrt(x))\n   .map(v=>v*v)\n  res1 = ar74.map(x => td1(x));\n  B_B = res2 = res1.map(y => td2(y));\n  C_C = res3 = ar74.map(z => td2(td1(z)));\n  D_D = transducerResult = ar74.reduce(xform3(concat),[] );\n}\n\n  function Filt (p) {this.p = p; this.filt = function filt (x) {return p(x)}};\n  let fives = function fives (x) {return new Filt(v => v % 10 === 5)}\n  let isOdd = function isOdd (x) {return new Filt(v => v % 2 === 1)};\n\n  let td1 = x => Monad([x])(isOdd)(v=>v**4)(v=>v+3)\n    (v=>v-3)(fives)(Math.sqrt)('stop').pop()\n  res1 = ar74.map(x => td1(x));\n  let td2 = y => Monad([y])(v=>v*v)(v=>v+1000)('stop').pop()`\n\nlet call2 = `xform3 = compose(\n    tdFilter(x=>x%2===1),\n    tdMap(x => x**4),\n    tdMap(x => x+3),\n    tdMap(x => x-3),\n    tdFilter(x => x % 10 === 5),\n    tdMap(x => Math.sqrt(x)),\n    tdMap(x=>x*x),\n    tdMap(x=>x+1000)\n  );\n\n  function tdMap(func) {\n    return function(reducingFunction) {\n      return (accumulator, v) => {\n        return reducingFunction(accumulator, func(v));\n      }\n    }\n  }\n\n  function tdFilter(test) {\n    return function(reducingFunction) {\n      return (accumulator, v) => {\n        return (test(v) ? reducingFunction(accumulator, v) : accumulator)\n      };\n    };\n  }; `\n\n  function increase () {\n    size = size + 10;\n    ar74 = [...Array(size).keys()];\n    res1 = ar74.map(x => td1(x));\n     A_A = dotResult = ar74\n     .filter(v => (v % 2 === 1))\n     .map(x => x**4)\n     .map(x => x+3)\n     .map(x => x-3)\n     .filter(v => v % 10 === 5)\n     .map(x => Math.sqrt(x))\n     .map(v=>v*v)\n     .map(v=>v+1000)\n    B_B = res2 = res1.map(y => td2(y));\n    C_C = res3 = ar74.map(z => td2(td1(z)));\n    D_D = transducerResult = ar74.reduce(xform3(concat),[] );\n  }\n\nfunction decrease () {\n  size = size - 10;\n  ar74 = [...Array(size).keys()];\n  res1 = ar74.map(x => td1(x));\n   A_A = dotResult = ar74\n   .filter(v => (v % 2 === 1))\n   .map(x => x**4)\n   .map(x => x+3)\n   .map(x => x-3)\n   .filter(v => v % 10 === 5)\n   .map(x => Math.sqrt(x))\n   .map(v=>v*v)\n   .map(v=>v+1000)\n  B_B = res2 = res1.map(y => td2(y));\n  C_C = res3 = ar74.map(z => td2(td1(z)));\n  D_D = transducerResult = ar74.reduce(xform3(concat),[] );\n}\n\n$: size;\n$: ar74;\n$: increase;\n$: decrease;\nincrease();\ndecrease();\n  </script>\n<style>\n.p {\n  color: #FFAAAA;;\n  font-size: 20px;\n}\n.q {\n  color: #FFFFAA;\n}\n</style>\n{#if visible}\n <div style = \"font-family: Times New Roman;  text-align: center; color: hsl(210, 90%, 90%); font-size: 32px;\" transition:fade>\nTRANSDUCER SIMULATION\n </div>\n{/if}\n\n<p> The tradition JavaScript method of composing functions using mainly map, filter, and reduce dot notation (eg. \"array.map(func1).filter(func2).map(func3)\") polutes memory with arrays that are used only to compute the next array in a chain. Moreover, each of the soon-to-be useless arrays must be traversed. When arrays are large and numerous functions are involved, this can be a performance bottleneck.</p>\n<p> Transducers provide an ingenious solution to the problem. Any JavaScript developer who hasn't already done so would do well to get a good night's sleep, drink a big cup of coffee, and wrap his or her head around the transducer algorithm.</p>\n<p> Another, more straightforward one-array-traversal solution is to use monads. This post shows the result of an array being traversed only one time and, with the help of a monad, undersoing multiple transformations by a collection of functions. The result is the same result obtained by the dot method and a standard transducer.</p>\n<p> The following results were obtained by eight transformations on an array of the first 100 integers:</p>\n<br><br>\n<div>Result length is {transducerResult.length}</div>\n<br><br>\n<div class = p> Traditional dot composition </div>\n<br>\n<div class = q >[{A_A.join(\", \")}]</div>\n<br>\n<br>\n<div class = p> Composition in two stages using Monad </div>\n<br>\n<div class = q > [{B_B.join(\", \")}]</div>\n<br>\n<br>\n<div class = p> Composition in one traversal using Monad </div>\n<br>\n<div class = q > [{C_C.join(\", \")}]</div>\n<br>\n<br>\n<div class = p> Composition using a standard transducer </div>\n<br>\n<div class = q > [{D_D.join(\", \")}]</div>\n<br>\n<br>\n<button class = but on:click = {increase}>INCREASE</button>\n<button class = but on:click = {decrease}>DECREASE</button>\n<br><br>\n<div>Array length: {size}</div>\n<br>\n<div>ar74: [{ar74.join(\", \")}]</div>\n<br>\n<div>The modified Monad (below) could benefit from some refactoring, but it does what needs to be done for this demo. The point is that a standard transducer and Monad both use one array traversal to accomplish what the built-in dot method does by traversing the original array and seven intermediary arrays. </div>\n<pre>{mon44}</pre>\n<p> On my desktop computer, when ar74.length === 100,000 I got this and similar results: </p>\n<div style = \"color: #BBFFBB\">ar74.length = 100,000:</div>\n\n<pre>Dot method:: 25 ms\nMonad two traversals: 255 ms\nMonad one traversal: 220 ms\nTransducer: 26 ms </pre>\n<p> ar74.length === 1,000,000 was about as far as I could go without crashing the browser. Here are two typical results: </p>\n\n<div style = \"color: #BBFFBB\">Two runs with ar74.length = 1,000,000:</div>\n\n<pre>Dot method:: 276\nMonad two traversals: 2140\nMonad one traversal: 2060\nTransducer: 180\n\nDot method:: 312\nMonad two traversals: 2093\nMonad one traversal: 2115\nTransducer: 176 </pre>\n<p> As you see, the built-in JavaScript dot method and the transducer gave similar results. The Monad methods are much slower. They're just a proof-of-concept hacks showing the versitility of monads spawned by Monad(). </p>\n<p> Here's the definition of the increase button's callback function along with the definitions of some assoc some supportingrelated: </p>\n<pre>{callback}</pre>\n<p> And here's some of the code behind the transducer demonstration: </p>\n<pre>{call2}</pre>\n<span> The rest of the code can be found in the </span>\n<a href = \"https://github.com/dschalk/blog\">Github repository</a>\n<span>.</span>\n"
  ],
  "names": [],
  "mappings": "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"
}