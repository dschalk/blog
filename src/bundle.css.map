{
  "version": 3,
  "file": "bundle.css",
  "sources": [
    "../src/Monad.svelte",
    "../src/Haskell.svelte"
  ],
  "sourcesContent": [
    "\n<script>\nimport {fade} from \"svelte/transition\"\nlet visible = true;\n\nlet monadDisplay = `function Monad (z) {\n    var x = z;\n    var foo = function foo (func) {\n        var stop = 'stop';\n        if (func.name === 'stop') return x\n        else {\n            x = func(x);\n            return foo;\n        }\n    };\n    return foo;\n}\n\nconst prod = a => b => a*b;\nconst sum = a => b => a+b;`\n\nlet bonadsD = `function bonads(num) {\nreturn [Monad(num)(sum(7))(prod(4))(v=>v-10)(stop),\nMonad(num-1)(sum(7))(prod(4))(v=>v-10)(stop),\nMonad(num-2)(sum(7))(prod(4))(v=>v-10)(stop),\nMonad(num-3)(sum(7))(prod(4))(v=>v-10)(stop),\nMonad(num-2)(sum(7))(prod(4))(v=>v-10)(stop),\nMonad(num-1)(sum(7))(prod(4))(v=>v-10)(stop),\nMonad(num-0)(sum(7))(prod(4))(v=>v-10)(stop)]}`\n\nlet axe = `\nlet mon = Monad(3);\nlet a = mon(x=>x**3)(x=>x+3)(x=>x**2)(stop);\nconsole.log(\"a is\", a)  // a is 900`\n\nlet tree = `\nmon(x => x/100)\nconsole.log(\"mon(stop) now is\",mon(stop))  // mon(stop) now is 9 `\n\nlet fred = `\nlet ar = [];\nlet mon = Monad(3);\nlet mon2 = Monad();\nar.push(mon(stop));\nvar a = mon(x=>x**3)(x=>x+3)(x=>x**2)(stop)\nar.push(a);\nar.push(mon(x => x/100)(stop));\nar.push(mon2(mon(stop)(x=>x*100)))\nconsole.log(\"ar is\", ar)  // [3, 900, 9] `\n\nfunction Monad (z) {\n  var x = z;\n  var stop = \"stop\";\n  var foo = function foo (func) {\n    if (func.name === \"stop\") return x\n    else {\n      x = func(x);\n      return foo;\n    }\n  };\n  return foo;\n}\n\nconst prod = a => b => a*b;\nconst sum = a => b => a+b;\n\nlet num = 6;\n\nlet bonads = function bonads(num) {\nreturn [Monad(num)(sum(7))(prod(4))(v=>v-10)(stop),\nMonad(num-1)(sum(7))(prod(4))(v=>v-10)(stop),\nMonad(num-2)(sum(7))(prod(4))(v=>v-10)(stop),\nMonad(num-3)(sum(7))(prod(4))(v=>v-10)(stop),\nMonad(num-2)(sum(7))(prod(4))(v=>v-10)(stop),\nMonad(num-1)(sum(7))(prod(4))(v=>v-10)(stop),\nMonad(num-0)(sum(7))(prod(4))(v=>v-10)(stop)]}\n\n\nlet mona = bonads(num);\n$: mona\nconsole.log(mona)\n\nlet ar = [];\nlet mon = Monad(3);\nlet mon2 = Monad();\nar.push(mon(stop));\nvar a = mon(x=>x**3)(x=>x+3)(x=>x**2)(stop)\nar.push(a);\nar.push(mon(x => x/100)(stop));\nar.push(mon2(()=>mon(stop))(x=>x*100)(stop))\n\nfunction numF (e) {num = e.target.value; console.log(\"e.target.value is\", e.target.value); return e.target.value}\n$: num\n\nconsole.log(\"num is\", num);\n</script>\n\n<style>\n\nh3 {\n   font-size: 27px;\n}\n\n#aside {\n    font-size: 18px;\n    color: #eeaaff;\n    font-style: italic;\n}\n\n</style>\n {#if visible}\n \t<div style = \"font-family: Times New Roman;  text-align: center; color: hsl(210, 90%, 90%); font-size: 32px;\" transition:fade>\nA SIMPLE LITTLE MONAD\n \t</div>\n {/if}\n<br>\n<span class = tao> The word \"monad\" has been around for centuries. Gottfried Leibniz published </span>\n<span style = \"font-style: italic\"> Monadology </span>\n<span> in 1714. The precursor to the familiar symbol of yin-yang, taijitu (太極圖), has a version with two dots added, has been given the august designation: \"The Great Monad\". A single note in music theory is called a monad. All of this is too tangential to warrant references. I Googled around a little to get it and you can too if the word \"monad\" interests you.</span>\n<p> Monads in the Haskell Programming Language were inspired by Category Theory monads. In order to be Category Theory monads, function must exist in a mathematically rigorous \"category\". Haskells objects and functions are not the objects and morphisms of Category Theory. Making a category out of most of Haskell's functions and types is an amusing pasttime for some people, but I doubt that it has any practical value. </p>\n<p> So it should be no surprise that my JavaScript monads are not Category Theory monads. They do obey a JavaScript version of the Haskell monad laws, which are not a requirement in Haskell but are indicative of utility and robustness objects (including functions) don't constitute a category. But functions that hold values and compose with multiple functions that operate on their values behave like Category Theory monads enough to justify calling them \"monads\".</p>\n<p> Here's the definitions of three functions: </p>\n<pre>{monadDisplay}</pre>\n<p> And here is an anonymous monad followed by three functions and \"stop\". : </p>\n<pre> Monad(6)(sum(7))(prod(4))(v=>v-10)(stop) // 42 </pre>\n<p> Anonymous monads never interfere with other monads. The demonstration below illustrates this by running seven anonymous monads in rapid succession. The number you enter is \"num\" in </p>\n{bonadsD}\n<input id = \"one\" type = \"number\" on:input={bonads}  bind:value={num} />\n<p> num is {num} so bonads(num) returns {bonads(num)} </p>\n\n<span class = tao> Named monads retain their values, even after they encounter \"stop\" and return the value of x held in the Monad closure. The following examples illustrate this: </span>\n<pre>\n{axe}\n</pre>\n\n<p> As expected, mon returns which is the \"foo()\" returned by by calling Monad(3):</p>\n{mon}\n\n<p> mon() is still the foo() returned by Monad(). Because mon() maintains a reference to the x in the context of its creation, x will not be garbage collected. </p>\n\n<p> It is convenient to have state, in the form of x, safely tucked away in a closure; but if later in your program you no longer have any use for x, it's up to you to destroy the named monad that points to it. </p>\n<p> One reason Svelte is so fast and efficient is that it mutates variables and objects. In this and other ways, Svelte has shaken off the bonds of current conventional \"wisdom\". </p>\n<p>If you want to save older versions of a monad, you can stash it in an ordinary curly braces object, an array, a set, etc. Here's some code that demonstrates preserving a monad's history. It also demonstrates a monad named \"mon2\" branching off of mon and going its own way. </p>\n<pre>{fred}</pre>\n<p> ar is {ar} </p>\n<span class = tao> Another technique is to keep the array of computation results in the closure.  It would then be convenient to run functions on array elements or the array itself. Monads could be asynchronous, populating the array with Promise resolution values. They could even be made to perform multiple array transformation - including map, filter, and reduce - in a single step, just as transducers do. To see a monad that does all of these things, click \"A Swiss Army Knife Monad\". </span>\n<span id = aside> By the way, I leave sentence punctuation outside of quotation marks, which is customary in the UK and eliminates the ambiguity inherent in the standard American syntax.</span>\n",
    "\n\n\n<script>\nimport {fade} from \"svelte/transition\"\nlet visible = true;\n\nlet GHC_IO = `module GHC.IO.Unsafe (\n    unsafePerformIO, unsafeInterleaveIO,\n    unsafeDupablePerformIO, unsafeDupableInterleaveIO,\n    noDuplicate,\n  ) where\n\nimport GHC.Base\n\nThis is a \\\"back door\\\" into the \\'IO\\' monad, allowing\\'IO\\' computation to be performed at any time.  For this to be safe, the \\'IO\\' computation should be free of side effects and independent of its environment.\n `\n</script>\n\n<style>\n\nh3 {\n    font-size: 27px;\n}\n#large {\n     font-size: 23px;\n     color: #aaddff;\n}\n</style>\n{#if visible}\n <div style = \"font-family: Times New Roman; text-align: center; color: hsl(210, 90%, 90%); font-size: 32px;\" transition:fade>\n <br><br>\nHASKELL TUTORIAL SUPPLEMENT\n </div>\n{/if}\n\n<p> If you are learning to program in Haskell, the book or blog or YouTube video on which you rely might be telling you that mutations can occur only inside of monads or somewhere away from a program such as the command line or a browser. You might be learning that mutations and side effects can occur only in the lazy IO monad. If so, don't believe it. You are being misled.  </p>\n<p> Even if you resent being lied to, you might find value in some of the dishonest learning resources. They are trying to teach best practices. Just know know that it is easy to mutate values and types anywhere in a Haskell program. Doing so before you know what your compiler (presumably GHC) will do with your mutations is asking for bugs and crashes.  Here are some unsafe functions with descriptions from their creators and maintainers: </p>\n<p id = large> Unsafe.Coerce </p>\n<p> The highly unsafe primitive unsafeCoerce converts a value from any type to any other type. Needless to say, if you use this function, it is your responsibility to ensure that the old and new types have identical internal representations, in order to prevent runtime corruption. </p>\n<span class = tao> The only function in this library is unsafeCoerce :: a -> b. You can read more about it at </span>\n<a href = \"http://hackage.haskell.org/package/base-4.12.0.0/docs/Unsafe-Coerce.html\" target = \"_blank\">Unsafe.Coerce</a>\n<br />\n<pre> GHC.IO.Unsafe </pre>\n<p> If the IO computation wrapped in \\'unsafePerformIO\\' performs side effects, then the relative order in which those side effects take place (relative to the main IO trunk, or other calls to \\'unsafePerformIO\\') is indeterminate.  Furthermore, when using \\'unsafePerformIO\\' to cause side-effects, you should take the following precautions to ensure the side effects are performed as many times as you expect them to be.  Note that these precautions are necessary for GHC, but may not be sufficient, and other compilers may require different precautions. </p>\n<span class = tao > For more information, go to </span>\n<a href = \"http://hackage.haskell.org/package/base-4.12.0.0/docs/src/GHC.IO.Unsafe.html\" target = \"_blank\"> GHC.IO.Unsafe </a>\n<br />\n<br />\n<span class = tao> And here\\'s a stub on the Haskell Wiki site that isn\\'t generating much interest: </span>\n<a href = \"https://wiki.haskell.org/Unsafe_functions\" target = \"_blank\" > More on GHC.IO.Unsafe </a>\n<span> along with a discussion of mutable global variables in Haskell programs: </span>\n<a href = \"https://wiki.haskell.org/Top_level_mutable_state\" target = \"_blank\"> Top level mutable state </a>\n"
  ],
  "names": [],
  "mappings": "AAuGA,MAAM,cAAC,CAAC,AACJ,SAAS,CAAE,IAAI,CACf,KAAK,CAAE,OAAO,CACd,UAAU,CAAE,MAAM,AACtB,CAAC;ACnFD,MAAM,cAAC,CAAC,AACH,SAAS,CAAE,IAAI,CACf,KAAK,CAAE,OAAO,AACnB,CAAC"
}